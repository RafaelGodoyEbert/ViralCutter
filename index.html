<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dividir texto pro ChatGPT</title>
	<style>
		body {
			font-family: Arial, sans-serif;
			margin: 20px;
			background-color: #fff; /* Cor de fundo clara padrão */
			color: #000; /* Texto escuro padrão */
			transition: background-color 0.3s, color 0.3s;
		}
		textarea, input[type="text"], input[type="number"] {
			width: 60%; /* Aumenta a largura para 60% */
			max-width: 1000px; /* Limita a largura máxima */
			margin: 10px auto; /* Centraliza horizontalmente */
			padding: 5px;
			border: 1px solid #ccc; /* Bordas padrão */
			border-radius: 6px;
			transition: background-color 0.3s, color 0.3s, border-color 0.3s;
			display: block; /* Faz com que os elementos sejam exibidos como blocos */
		}
		textarea {
			height: 150px;
		}
		button {
			margin: 10px auto; /* Centraliza o botão horizontalmente */
			padding: 5px 10px;
			background-color: #4CAF50;
			color: white;
			border: none;
			cursor: pointer;
			transition: background-color 0.3s;
			display: block; /* Exibe o botão como bloco */
			width: 60%; /* Aumenta a largura para 60% */
			max-width: 200px; /* Limita a largura máxima do botão */
		}
		button:hover {
			background-color: #45a049;
		}
		button.copied {
			background-color: #808080;
			cursor: default;
		}
		.chunk {
			background-color: #f9f9f9;
			border: 1px solid #ddd;
			padding: 10px;
			margin: 10px auto; /* Centraliza o bloco */
			width: 60%; /* Aumenta a largura para 60% */
			max-width: 1000px; /* Limita a largura máxima */
			height: 100px;
			overflow-y: auto;
			position: relative;
			transition: background-color 0.3s, border-color 0.3s;
			display: block; /* Exibe o bloco como bloco */
		}
		.copy-container {
			text-align: right;
			margin-bottom: 10px;
		}
		.block-title {
			font-weight: bold;
			margin-bottom: 5px;
			text-align: center; /* Centraliza o título */
		}
		.config-section {
			margin: 20px auto; /* Centraliza a seção de configuração */
			padding: 10px;
			width: 60%; /* Aumenta a largura para 60% */
			max-width: 1000px; /* Limita a largura máxima */
			transition: background-color 0.3s, border-color 0.3s;
		}
		.config-toggle {
			cursor: pointer;
			user-select: none;
			display: inline; /* Mantém o texto no mesmo nível, sem fundo */
		}
		.config-content {
			display: none;
			margin-top: 10px;
			width: 99%; /* Faz com que a seção preencha toda a largura disponível */
		}
		.config-content > textarea, 
		.config-content > input[type="text"], 
		.config-content > input[type="number"],
		.config-content .chunk {
			width: 100%; /* Faz com que os elementos internos preencham a largura total */
			max-width: none; /* Remove a limitação de largura máxima */
			margin: 10px 0; /* Espaçamento vertical entre os elementos */
		}
		/* Estilos para o modo escuro */
		.dark-mode {
			background-color: #121212;
			color: #ffffff;
		}
		.dark-mode .chunk {
			background-color: #1e1e1e;
			border-color: #444;
		}
		.dark-mode .config-section {
			background-color: #2c2c2c;
		}
		.dark-mode textarea, 
		.dark-mode input[type="text"], 
		.dark-mode input[type="number"] {
			background-color: #333; /* Cor de fundo para input no modo escuro */
			color: #fff; /* Cor do texto para input no modo escuro */
			border-color: #555; /* Cor da borda para input no modo escuro */
		}
	</style>


</head>
<body>
    <center><h1>Dividir texto pro ChatGPT</h1></center>
    
    <textarea id="srtInput" placeholder="Cole o conteúdo que você quer dividir aqui"></textarea>
    <div class="config-section">
        <h3 class="config-toggle" onclick="toggleConfig()">▶ Configurações</h3>
        <div id="configContent" class="config-content">
            <label for="intermediateText">Texto para blocos intermediários:</label>
            <input type="text" id="intermediateText" value="Reply OK and I will send you the rest of the script.">
            
            <label for="finalText">Texto para o bloco final:</label>
            <textarea id="finalText">You are a Viral Segment Identifier, an AI system that analyzes a video's transcript and predicts which segments might go viral on social media platforms. You use factors such as emotional impact, humor, unexpected content, and relevance to current trends to make your predictions. You return a structured text document detailing the start and end times, the description, the duration, and a viral score for the potential viral segments.

Given the following video transcript, analyze the part for potential virality and identify 3 most viral segments from the transcript. Each segment must have a duration between 50 and 90 seconds. It is MANDATORY to respect the specified number of viral segments, the minimum duration, and the maximum duration. Additionally, the cuts MUST MAKE SENSE and cannot end abruptly without context. The transcript provided is above:

Based on your analysis, return a structured text document containing the timestamps (start and end), the description of the viral part, its duration, a suggested viral title, and a score indicating the probability of going viral. Please follow this format for each segment.

        { "segments" :
            [
                {
                    "title": "Suggested Viral Title",
                    "start_time": "00:00:00", #HH:MM:SS
                    "end_time": "00:00:00", #HH:MM:SS
                    "description": "Description of the text",
                    "duration": 0,
                    "score": 0  # Probability of going viral (0-100)
                }
            ]
        }</textarea>

            <label for="maxChunkSize">Tamanho máximo do chunk (em caracteres):</label>
            <input type="number" id="maxChunkSize" value="14000" min="1">
            
            <label for="darkModeToggle">Ativar Modo Escuro:</label>
            <input type="checkbox" id="darkModeToggle">
            
            <button onclick="saveConfig()">Salvar Configurações</button>
        </div>
    </div>
    <button onclick="convertSRTtoTSV()">Converter</button>
    <div id="output"></div>

    <script>
        function toggleConfig() {
            const content = document.getElementById('configContent');
            const toggle = document.querySelector('.config-toggle');
            if (content.style.display === 'none' || content.style.display === '') {
                content.style.display = 'block';
                toggle.textContent = '▼ Configurações';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶ Configurações';
            }
        }

        function saveConfig() {
            const intermediateText = document.getElementById('intermediateText').value;
            const finalText = document.getElementById('finalText').value;
            const maxChunkSize = document.getElementById('maxChunkSize').value;
            const darkMode = document.getElementById('darkModeToggle').checked;

            localStorage.setItem('intermediateText', intermediateText);
            localStorage.setItem('finalText', finalText);
            localStorage.setItem('maxChunkSize', maxChunkSize);
            localStorage.setItem('darkMode', darkMode); // Salva a configuração do modo escuro
            
            applyDarkMode(darkMode); // Aplica o modo escuro
            alert('Configurações salvas com sucesso!');
        }

        function loadConfig() {
            const intermediateText = localStorage.getItem('intermediateText');
            const finalText = localStorage.getItem('finalText');
            const maxChunkSize = localStorage.getItem('maxChunkSize');
            const darkMode = localStorage.getItem('darkMode') === 'true'; // Converte para booleano

            if (intermediateText) {
                document.getElementById('intermediateText').value = intermediateText;
            }
            if (finalText) {
                document.getElementById('finalText').value = finalText;
            }
            if (maxChunkSize) {
                document.getElementById('maxChunkSize').value = maxChunkSize;
            }
            document.getElementById('darkModeToggle').checked = darkMode; // Carrega a configuração do modo escuro
            applyDarkMode(darkMode); // Aplica o modo escuro se estiver ativado
        }

        function applyDarkMode(enabled) {
            if (enabled) {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
        }
		
		function convertSRTtoTSV() {
            const srtInput = document.getElementById('srtInput').value;
            const intermediateText = document.getElementById('intermediateText').value;
            const finalText = document.getElementById('finalText').value;
            const maxChunkSize = parseInt(document.getElementById('maxChunkSize').value);
            const output = document.getElementById('output');
            output.innerHTML = '';

            // Verifica se o input é um SRT
            if (isValidSRT(srtInput)) {
                const tsvLines = srtToTsv(srtInput);
                const chunks = splitIntoChunks(tsvLines.join('\n'), maxChunkSize);

                chunks.forEach((chunk, index) => {
                    const blockTitle = document.createElement('div');
                    blockTitle.classList.add('block-title');
                    blockTitle.textContent = `Bloco ${index + 1}:`;
                    output.appendChild(blockTitle);

                    const chunkContainer = document.createElement('div');
                    chunkContainer.classList.add('chunk');

                    const preElement = document.createElement('pre');
                    if (chunks.length === 1 || index === chunks.length - 1) {
                        preElement.textContent = `${chunk}\n\n${finalText}`;
                    } else {
                        preElement.textContent = `${chunk}\n\n${intermediateText}`;
                    }

                    const copyContainer = document.createElement('div');
                    copyContainer.classList.add('copy-container');

                    const copyButton = document.createElement('button');
                    copyButton.textContent = 'Copiar chunk';
                    copyButton.onclick = () => copyToClipboard(preElement.textContent, copyButton);

                    copyContainer.appendChild(copyButton);
                    output.appendChild(chunkContainer);
                    output.appendChild(copyContainer);

                    chunkContainer.appendChild(preElement);
                });
            } else {
                // Caso não seja um SRT, divide o texto pelo número de caracteres
                const chunks = splitIntoChunks(srtInput, maxChunkSize);
                chunks.forEach((chunk, index) => {
                    const blockTitle = document.createElement('div');
                    blockTitle.classList.add('block-title');
                    blockTitle.textContent = `Bloco ${index + 1}:`;
                    output.appendChild(blockTitle);

                    const chunkContainer = document.createElement('div');
                    chunkContainer.classList.add('chunk');

                    const preElement = document.createElement('pre');
                    if (chunks.length === 1 || index === chunks.length - 1) {
                        preElement.textContent = `${chunk}\n\n${finalText}`;
                    } else {
                        preElement.textContent = `${chunk}\n\n${intermediateText}`;
                    }

                    const copyContainer = document.createElement('div');
                    copyContainer.classList.add('copy-container');

                    const copyButton = document.createElement('button');
                    copyButton.textContent = 'Copiar chunk';
                    copyButton.onclick = () => copyToClipboard(preElement.textContent, copyButton);

                    copyContainer.appendChild(copyButton);
                    output.appendChild(chunkContainer);
                    output.appendChild(copyContainer);

                    chunkContainer.appendChild(preElement);
                });
            }
        }
		
        function isValidSRT(srtContent) {
            // Verifica se o conteúdo é um SRT básico (apenas um exemplo simples)
            const lines = srtContent.trim().split('\n');
            return lines.length > 2 && /^\d+\s*$/.test(lines[0]) && lines[1].includes('-->');
        }

        function srtToTsv(srtContent) {
            const lines = srtContent.trim().split('\n');
            const tsvLines = [];
            let index = 1;

            for (let i = 0; i < lines.length; i += 4) {
                const timeStamp = lines[i + 1];
                const text = lines[i + 2];

                if (timeStamp && text) {
                    const [start, end] = timeStamp.split(' --> ');
                    tsvLines.push(`${index}\t${start}\t${end}\t${text}`);
                    index++;
                }
            }

            return tsvLines;
        }

        function splitIntoChunks(text, maxLength) {
			const lines = text.split('\n');
			let chunks = [];
			let currentChunk = '';
			let currentChunkLength = 0;

			lines.forEach(line => {
				const lineLength = line.length + 1; // +1 para o '\n'
				if (currentChunkLength + lineLength > maxLength) {
					chunks.push(currentChunk.trim());
					currentChunk = '';
					currentChunkLength = 0;
				}
				currentChunk += line + '\n';
				currentChunkLength += lineLength;
			});

			if (currentChunk.length > 0) {
				chunks.push(currentChunk.trim());
			}

			return chunks;
		}

        function copyToClipboard(text, button) {
			navigator.clipboard.writeText(text)
				.then(() => {
					button.textContent = 'Copiado!';
					button.classList.add('copied');
				})
				.catch(err => {
					console.error('Erro ao copiar para a área de transferência: ', err);
				});

			// Adiciona um evento de clique para redefinir o botão
			button.addEventListener('click', () => {
				if (button.classList.contains('copied')) {
					button.textContent = 'Copiar'; // Texto original do botão
					button.classList.remove('copied'); // Remove a classe
				}
			});
		}


        loadConfig(); // Carrega as configurações ao iniciar
    </script>
</body>
</html>
