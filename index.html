<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dividir texto pro ChatGPT</title>
	<style>
		body {
			font-family: Arial, sans-serif;
			margin: 20px;
			background-color: #fff; /* Cor de fundo clara padrão */
			color: #000; /* Texto escuro padrão */
			transition: background-color 0.3s, color 0.3s;
		}
		textarea, input[type="text"], input[type="number"] {
			width: 60%; /* Aumenta a largura para 60% */
			max-width: 1000px; /* Limita a largura máxima */
			margin: 10px auto; /* Centraliza horizontalmente */
			padding: 5px;
			border: 1px solid #ccc; /* Bordas padrão */
			border-radius: 6px;
			transition: background-color 0.3s, color 0.3s, border-color 0.3s;
			display: block; /* Faz com que os elementos sejam exibidos como blocos */
		}
		textarea {
			height: 150px;
		}
		button {
			margin: 10px auto; /* Centraliza o botão horizontalmente */
			padding: 5px 10px;
			background-color: #4CAF50;
			color: white;
			border: none;
			cursor: pointer;
			transition: background-color 0.3s;
			display: block; /* Exibe o botão como bloco */
			width: 60%; /* Aumenta a largura para 60% */
			max-width: 200px; /* Limita a largura máxima do botão */
		}
		button:hover {
			background-color: #45a049;
		}
		button.copied {
			background-color: #808080;
			cursor: default;
		}
		.chunk {
			background-color: #f9f9f9;
			border: 1px solid #ddd;
			padding: 10px;
			margin: 10px auto; /* Centraliza o bloco */
			width: 60%; /* Aumenta a largura para 60% */
			max-width: 1000px; /* Limita a largura máxima */
			height: 100px;
			overflow-y: auto;
			position: relative;
			transition: background-color 0.3s, border-color 0.3s;
			display: block; /* Exibe o bloco como bloco */
		}
		.copy-container {
			text-align: right;
			margin-bottom: 10px;
		}
		.block-title {
			font-weight: bold;
			margin-bottom: 5px;
			text-align: center; /* Centraliza o título */
		}
		.config-section {
			margin: 20px auto; /* Centraliza a seção de configuração */
			padding: 10px;
			width: 60%; /* Aumenta a largura para 60% */
			max-width: 1000px; /* Limita a largura máxima */
			transition: background-color 0.3s, border-color 0.3s;
		}
		.config-toggle {
			cursor: pointer;
			user-select: none;
			display: inline; /* Mantém o texto no mesmo nível, sem fundo */
		}
		.config-content {
			display: none;
			margin-top: 10px;
			width: 99%; /* Faz com que a seção preencha toda a largura disponível */
		}
		.config-content > textarea, 
		.config-content > input[type="text"], 
		.config-content > input[type="number"],
		.config-content .chunk {
			width: 100%; /* Faz com que os elementos internos preencham a largura total */
			max-width: none; /* Remove a limitação de largura máxima */
			margin: 10px 0; /* Espaçamento vertical entre os elementos */
		}
		/* Estilos para o modo escuro */
		.dark-mode {
			background-color: #121212;
			color: #ffffff;
		}
		.dark-mode .chunk {
			background-color: #1e1e1e;
			border-color: #444;
		}
		.dark-mode .config-section {
			background-color: #2c2c2c;
		}
		.dark-mode textarea, 
		.dark-mode input[type="text"], 
		.dark-mode input[type="number"] {
			background-color: #333; /* Cor de fundo para input no modo escuro */
			color: #fff; /* Cor do texto para input no modo escuro */
			border-color: #555; /* Cor da borda para input no modo escuro */
		}
	</style>


</head>
<body>
    <center><h1>Dividir texto pro ChatGPT</h1></center>
    
    <textarea id="srtInput" placeholder="Cole o conteúdo que você quer dividir aqui"></textarea>
    <div class="config-section">
        <h3 class="config-toggle" onclick="toggleConfig()">▶ Configurações</h3>
        <div id="configContent" class="config-content">
            <label for="intermediateText">Texto para blocos intermediários:</label>
            <input type="text" id="intermediateText" value="Responda com OK que vou enviar o restante do script.">
            
            <label for="finalText">Texto para o bloco final:</label>
            <textarea id="finalText">Agora você é especialista em Youtube e preciso que você separe esse vídeo em tópicos, mostrando o tempo

Quero que fique nesse padrão:

00:00 Introdução
01:00 assunto X
02:00 assunto Y

Envie em plaintext
Lembrando que os tempos são apenas exemplos, você vai analisar a legenda e definir os tempos de cada assunto e não precisa adicionar comentários entre cada tempo. Também não precisa ser tão específico, quero que pegue o assunto geral. A duração mínima de cada capítulo é de 10 segundos.</textarea>

            <label for="maxChunkSize">Tamanho máximo do chunk (em caracteres):</label>
            <input type="number" id="maxChunkSize" value="14000" min="1">
            
            <label for="darkModeToggle">Ativar Modo Escuro:</label>
            <input type="checkbox" id="darkModeToggle">
            
            <button onclick="saveConfig()">Salvar Configurações</button>
        </div>
    </div>
    <button onclick="convertSRTtoTSV()">Converter</button>
    <div id="output"></div>

    <script>
        function toggleConfig() {
            const content = document.getElementById('configContent');
            const toggle = document.querySelector('.config-toggle');
            if (content.style.display === 'none' || content.style.display === '') {
                content.style.display = 'block';
                toggle.textContent = '▼ Configurações';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶ Configurações';
            }
        }

        function saveConfig() {
            const intermediateText = document.getElementById('intermediateText').value;
            const finalText = document.getElementById('finalText').value;
            const maxChunkSize = document.getElementById('maxChunkSize').value;
            const darkMode = document.getElementById('darkModeToggle').checked;

            localStorage.setItem('intermediateText', intermediateText);
            localStorage.setItem('finalText', finalText);
            localStorage.setItem('maxChunkSize', maxChunkSize);
            localStorage.setItem('darkMode', darkMode); // Salva a configuração do modo escuro
            
            applyDarkMode(darkMode); // Aplica o modo escuro
            alert('Configurações salvas com sucesso!');
        }

        function loadConfig() {
            const intermediateText = localStorage.getItem('intermediateText');
            const finalText = localStorage.getItem('finalText');
            const maxChunkSize = localStorage.getItem('maxChunkSize');
            const darkMode = localStorage.getItem('darkMode') === 'true'; // Converte para booleano

            if (intermediateText) {
                document.getElementById('intermediateText').value = intermediateText;
            }
            if (finalText) {
                document.getElementById('finalText').value = finalText;
            }
            if (maxChunkSize) {
                document.getElementById('maxChunkSize').value = maxChunkSize;
            }
            document.getElementById('darkModeToggle').checked = darkMode; // Carrega a configuração do modo escuro
            applyDarkMode(darkMode); // Aplica o modo escuro se estiver ativado
        }

        function applyDarkMode(enabled) {
            if (enabled) {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
        }
		
		function convertSRTtoTSV() {
            const srtInput = document.getElementById('srtInput').value;
            const intermediateText = document.getElementById('intermediateText').value;
            const finalText = document.getElementById('finalText').value;
            const maxChunkSize = parseInt(document.getElementById('maxChunkSize').value);
            const output = document.getElementById('output');
            output.innerHTML = '';

            // Verifica se o input é um SRT
            if (isValidSRT(srtInput)) {
                const tsvLines = srtToTsv(srtInput);
                const chunks = splitIntoChunks(tsvLines.join('\n'), maxChunkSize);

                chunks.forEach((chunk, index) => {
                    const blockTitle = document.createElement('div');
                    blockTitle.classList.add('block-title');
                    blockTitle.textContent = `Bloco ${index + 1}:`;
                    output.appendChild(blockTitle);

                    const chunkContainer = document.createElement('div');
                    chunkContainer.classList.add('chunk');

                    const preElement = document.createElement('pre');
                    if (chunks.length === 1 || index === chunks.length - 1) {
                        preElement.textContent = `${chunk}\n\n${finalText}`;
                    } else {
                        preElement.textContent = `${chunk}\n\n${intermediateText}`;
                    }

                    const copyContainer = document.createElement('div');
                    copyContainer.classList.add('copy-container');

                    const copyButton = document.createElement('button');
                    copyButton.textContent = 'Copiar chunk';
                    copyButton.onclick = () => copyToClipboard(preElement.textContent, copyButton);

                    copyContainer.appendChild(copyButton);
                    output.appendChild(chunkContainer);
                    output.appendChild(copyContainer);

                    chunkContainer.appendChild(preElement);
                });
            } else {
                // Caso não seja um SRT, divide o texto pelo número de caracteres
                const chunks = splitIntoChunks(srtInput, maxChunkSize);
                chunks.forEach((chunk, index) => {
                    const blockTitle = document.createElement('div');
                    blockTitle.classList.add('block-title');
                    blockTitle.textContent = `Bloco ${index + 1}:`;
                    output.appendChild(blockTitle);

                    const chunkContainer = document.createElement('div');
                    chunkContainer.classList.add('chunk');

                    const preElement = document.createElement('pre');
                    if (chunks.length === 1 || index === chunks.length - 1) {
                        preElement.textContent = `${chunk}\n\n${finalText}`;
                    } else {
                        preElement.textContent = `${chunk}\n\n${intermediateText}`;
                    }

                    const copyContainer = document.createElement('div');
                    copyContainer.classList.add('copy-container');

                    const copyButton = document.createElement('button');
                    copyButton.textContent = 'Copiar chunk';
                    copyButton.onclick = () => copyToClipboard(preElement.textContent, copyButton);

                    copyContainer.appendChild(copyButton);
                    output.appendChild(chunkContainer);
                    output.appendChild(copyContainer);

                    chunkContainer.appendChild(preElement);
                });
            }
        }
		
        function isValidSRT(srtContent) {
            // Verifica se o conteúdo é um SRT básico (apenas um exemplo simples)
            const lines = srtContent.trim().split('\n');
            return lines.length > 2 && /^\d+\s*$/.test(lines[0]) && lines[1].includes('-->');
        }

        function srtToTsv(srtContent) {
            const lines = srtContent.trim().split('\n');
            const tsvLines = [];
            let index = 1;

            for (let i = 0; i < lines.length; i += 4) {
                const timeStamp = lines[i + 1];
                const text = lines[i + 2];

                if (timeStamp && text) {
                    const [start, end] = timeStamp.split(' --> ');
                    tsvLines.push(`${index}\t${start}\t${end}\t${text}`);
                    index++;
                }
            }

            return tsvLines;
        }

        function splitIntoChunks(text, maxLength) {
			const lines = text.split('\n');
			let chunks = [];
			let currentChunk = '';
			let currentChunkLength = 0;

			lines.forEach(line => {
				const lineLength = line.length + 1; // +1 para o '\n'
				if (currentChunkLength + lineLength > maxLength) {
					chunks.push(currentChunk.trim());
					currentChunk = '';
					currentChunkLength = 0;
				}
				currentChunk += line + '\n';
				currentChunkLength += lineLength;
			});

			if (currentChunk.length > 0) {
				chunks.push(currentChunk.trim());
			}

			return chunks;
		}

        function copyToClipboard(text, button) {
			navigator.clipboard.writeText(text)
				.then(() => {
					button.textContent = 'Copiado!';
					button.classList.add('copied');
				})
				.catch(err => {
					console.error('Erro ao copiar para a área de transferência: ', err);
				});

			// Adiciona um evento de clique para redefinir o botão
			button.addEventListener('click', () => {
				if (button.classList.contains('copied')) {
					button.textContent = 'Copiar'; // Texto original do botão
					button.classList.remove('copied'); // Remove a classe
				}
			});
		}


        loadConfig(); // Carrega as configurações ao iniciar
    </script>
</body>
</html>
